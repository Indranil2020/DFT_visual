"""
RDKit Integration for Psi4 MCP Server.

Provides cheminformatics capabilities via RDKit.
"""

from typing import Any, Dict, List, Optional, Tuple
import numpy as np


class RDKitInterface:
    """Interface for RDKit integration."""
    
    def __init__(self):
        """Initialize RDKit interface."""
        self._rdkit_available = self._check_rdkit()
    
    def _check_rdkit(self) -> bool:
        """Check if RDKit is available."""
        try:
            from rdkit import Chem
            return True
        except ImportError:
            return False
    
    @property
    def is_available(self) -> bool:
        """Check if RDKit is available."""
        return self._rdkit_available
    
    def smiles_to_mol(self, smiles: str) -> Optional[Any]:
        """
        Convert SMILES to RDKit mol object.
        
        Args:
            smiles: SMILES string
            
        Returns:
            RDKit mol object or None
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        return Chem.MolFromSmiles(smiles)
    
    def smiles_to_xyz(
        self,
        smiles: str,
        optimize: bool = True,
        add_hydrogens: bool = True,
    ) -> Optional[str]:
        """
        Convert SMILES to XYZ format with 3D coordinates.
        
        Args:
            smiles: SMILES string
            optimize: Whether to optimize geometry
            add_hydrogens: Whether to add hydrogens
            
        Returns:
            XYZ format string or None
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        from rdkit.Chem import AllChem
        
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        
        if add_hydrogens:
            mol = Chem.AddHs(mol)
        
        # Generate 3D coordinates
        result = AllChem.EmbedMolecule(mol, randomSeed=42)
        if result != 0:
            return None
        
        if optimize:
            AllChem.MMFFOptimizeMolecule(mol)
        
        # Convert to XYZ
        conf = mol.GetConformer()
        atoms = mol.GetAtoms()
        
        lines = [str(len(atoms)), "Generated by RDKit"]
        
        for i, atom in enumerate(atoms):
            symbol = atom.GetSymbol()
            pos = conf.GetAtomPosition(i)
            lines.append(f"{symbol:2s} {pos.x:15.10f} {pos.y:15.10f} {pos.z:15.10f}")
        
        return "\n".join(lines)
    
    def xyz_to_smiles(self, xyz: str) -> Optional[str]:
        """
        Convert XYZ to SMILES (requires bond perception).
        
        Args:
            xyz: XYZ format string
            
        Returns:
            SMILES string or None
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        from rdkit.Chem import AllChem
        
        # Parse XYZ
        lines = xyz.strip().split("\n")
        n_atoms = int(lines[0])
        
        # Create RWMol
        mol = Chem.RWMol()
        conf = Chem.Conformer(n_atoms)
        
        for i, line in enumerate(lines[2:2+n_atoms]):
            parts = line.split()
            symbol = parts[0]
            x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
            
            atom = Chem.Atom(symbol)
            idx = mol.AddAtom(atom)
            conf.SetAtomPosition(idx, (x, y, z))
        
        mol.AddConformer(conf)
        
        # Perceive connectivity
        Chem.rdDetermineBonds.DetermineConnectivity(mol)
        
        return Chem.MolToSmiles(mol)
    
    def calculate_descriptors(self, smiles: str) -> Dict[str, float]:
        """
        Calculate molecular descriptors.
        
        Args:
            smiles: SMILES string
            
        Returns:
            Dictionary of descriptors
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        from rdkit.Chem import Descriptors, Crippen, rdMolDescriptors
        
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return {}
        
        return {
            "molecular_weight": Descriptors.MolWt(mol),
            "exact_mass": Descriptors.ExactMolWt(mol),
            "logp": Crippen.MolLogP(mol),
            "tpsa": rdMolDescriptors.CalcTPSA(mol),
            "num_rotatable_bonds": rdMolDescriptors.CalcNumRotatableBonds(mol),
            "num_hbd": rdMolDescriptors.CalcNumHBD(mol),
            "num_hba": rdMolDescriptors.CalcNumHBA(mol),
            "num_heavy_atoms": rdMolDescriptors.CalcNumHeavyAtoms(mol),
            "num_rings": rdMolDescriptors.CalcNumRings(mol),
            "num_aromatic_rings": rdMolDescriptors.CalcNumAromaticRings(mol),
            "fraction_csp3": rdMolDescriptors.CalcFractionCSP3(mol),
        }
    
    def calculate_fingerprint(
        self,
        smiles: str,
        fp_type: str = "morgan",
        radius: int = 2,
        n_bits: int = 2048,
    ) -> Optional[np.ndarray]:
        """
        Calculate molecular fingerprint.
        
        Args:
            smiles: SMILES string
            fp_type: Fingerprint type (morgan, rdkit, maccs)
            radius: Morgan fingerprint radius
            n_bits: Number of bits
            
        Returns:
            Fingerprint as numpy array or None
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        from rdkit.Chem import AllChem, MACCSkeys
        
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        
        if fp_type == "morgan":
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=n_bits)
        elif fp_type == "rdkit":
            fp = Chem.RDKFingerprint(mol, fpSize=n_bits)
        elif fp_type == "maccs":
            fp = MACCSkeys.GenMACCSKeys(mol)
        else:
            return None
        
        return np.array(fp)
    
    def calculate_similarity(
        self,
        smiles1: str,
        smiles2: str,
        metric: str = "tanimoto",
    ) -> float:
        """
        Calculate molecular similarity.
        
        Args:
            smiles1: First SMILES
            smiles2: Second SMILES
            metric: Similarity metric (tanimoto, dice)
            
        Returns:
            Similarity score (0-1)
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import DataStructs
        
        fp1 = self.calculate_fingerprint(smiles1)
        fp2 = self.calculate_fingerprint(smiles2)
        
        if fp1 is None or fp2 is None:
            return 0.0
        
        # Convert to RDKit format
        from rdkit.Chem import AllChem
        from rdkit import Chem
        
        mol1 = Chem.MolFromSmiles(smiles1)
        mol2 = Chem.MolFromSmiles(smiles2)
        
        fp1_rd = AllChem.GetMorganFingerprintAsBitVect(mol1, 2, nBits=2048)
        fp2_rd = AllChem.GetMorganFingerprintAsBitVect(mol2, 2, nBits=2048)
        
        if metric == "tanimoto":
            return DataStructs.TanimotoSimilarity(fp1_rd, fp2_rd)
        elif metric == "dice":
            return DataStructs.DiceSimilarity(fp1_rd, fp2_rd)
        
        return 0.0
    
    def generate_conformers(
        self,
        smiles: str,
        n_conformers: int = 10,
        optimize: bool = True,
    ) -> List[str]:
        """
        Generate conformers for a molecule.
        
        Args:
            smiles: SMILES string
            n_conformers: Number of conformers
            optimize: Whether to optimize each conformer
            
        Returns:
            List of XYZ strings for each conformer
        """
        if not self._rdkit_available:
            raise ImportError("RDKit is not installed")
        
        from rdkit import Chem
        from rdkit.Chem import AllChem
        
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return []
        
        mol = Chem.AddHs(mol)
        
        # Generate conformers
        AllChem.EmbedMultipleConfs(mol, numConfs=n_conformers, randomSeed=42)
        
        if optimize:
            AllChem.MMFFOptimizeMoleculeConfs(mol)
        
        # Convert each conformer to XYZ
        xyz_list = []
        atoms = mol.GetAtoms()
        
        for conf_id in range(mol.GetNumConformers()):
            conf = mol.GetConformer(conf_id)
            
            lines = [str(len(atoms)), f"Conformer {conf_id + 1}"]
            
            for i, atom in enumerate(atoms):
                symbol = atom.GetSymbol()
                pos = conf.GetAtomPosition(i)
                lines.append(f"{symbol:2s} {pos.x:15.10f} {pos.y:15.10f} {pos.z:15.10f}")
            
            xyz_list.append("\n".join(lines))
        
        return xyz_list


# Global interface instance
_rdkit_interface: Optional[RDKitInterface] = None


def get_rdkit_interface() -> RDKitInterface:
    """Get the global RDKit interface."""
    global _rdkit_interface
    if _rdkit_interface is None:
        _rdkit_interface = RDKitInterface()
    return _rdkit_interface


def smiles_to_xyz(smiles: str, optimize: bool = True) -> Optional[str]:
    """Convert SMILES to XYZ."""
    interface = get_rdkit_interface()
    return interface.smiles_to_xyz(smiles, optimize)


def calculate_descriptors(smiles: str) -> Dict[str, float]:
    """Calculate molecular descriptors."""
    interface = get_rdkit_interface()
    return interface.calculate_descriptors(smiles)


def is_rdkit_available() -> bool:
    """Check if RDKit is available."""
    interface = get_rdkit_interface()
    return interface.is_available
